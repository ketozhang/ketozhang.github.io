<h2 id="compile-and-run-structure">Compile and Run Structure</h2>
<ul>
<li><code>.cpp</code>: The source file</li>
<li><code>.o</code>: The compiled file</li>
<li><code>.[EXECUTABLE]</code>: Executable file</li>
</ul>
<h2 id="hello-world">Hello World!</h2>
<p>As usual with some imports.</p>
<ul>
<li>Notice that the return type of the main function is <code>int</code> instead of <code>void</code> (never use <code>void</code> for this).</li>
<li>Notice the unique print to console syntax</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span><span class="pp"> </span><span class="co">// import I/O library</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std; <span class="co">// No need to specify `std`</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="dt">int</span> main() {</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="co">// prints &quot;Hello World!&quot; to console</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    cout &lt;&lt; <span class="st">&quot;Hello, World!</span><span class="sc">\n</span><span class="st">&quot;</span>; <span class="co">// More verbose, `std::cout`</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>}</span></code></pre></div>
<h2 id="function">Function</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>TYPE NAME([TYPE [ARG1], ...]) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="co">// body</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>}</span></code></pre></div>
<p>For example,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">double</span> square(<span class="dt">double</span> x) {</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="cf">return</span> x * x;</span>
<span id="cb3-3"><a href="#cb3-3"></a>}</span>
<span id="cb3-4"><a href="#cb3-4"></a></span></code></pre></div>
<p>Features</p>
<ul>
<li>Function overloading, allow synonyms with different type</li>
</ul>
<h2 id="variables">Variables</h2>
<p>Features</p>
<ul>
<li><p>Type declaration</p></li>
<li><p>Various ways of initialization</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a>type var = value;</span>
<span id="cb4-2"><a href="#cb4-2"></a>type var {value};</span>
<span id="cb4-3"><a href="#cb4-3"></a>type var = {value};</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">class</span>&lt;type&gt; var = {values, ...};</span></code></pre></div></li>
<li><p>Loss of information through conversion using <code>=</code>. Use the list form <code>{}</code> instead to error out when conversion occurs.</p></li>
<li><p>Implicit type <code>auto</code> (e.g., <code>auto b = true</code>) will automatically use the initialization to determine the type.</p></li>
<li><p>Constants supported <code>const</code> (run-time constant) and <code>constexpr</code> (compile-time constant). The latter is used for performance and memory corruption reasons which applies very strict requirements (e.g., immutability) on functions with <code>constexpr</code>.</p></li>
</ul>
<h2 id="basic-types">Basic Types</h2>
<p>There are many basic types for example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">bool</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="dt">char</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="dt">int</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="dt">double</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="dt">unsigned</span></span></code></pre></div>
<h2 id="arithmetic">Arithmetic</h2>
<p>All syntax is similar to Python.</p>
<p>Features</p>
<ul>
<li>Meaningful conversion between types (e.g., addition between int and double is double unless referenced by an int variable) preserves the highest precision.</li>
<li>Increment (<code>++x</code>) and decrement (<code>--x</code>).</li>
</ul>
<h2 id="scope">Scope</h2>
<p>There are four scopes:</p>
<ol type="1">
<li>Local scope</li>
<li>Class scope</li>
<li>Namespace scope A namespace is the point where the declaration is called to the end of the namespace (often end of the running file)</li>
<li>Global scope Everything else</li>
</ol>
<h2 id="pointers-references-and-arrays">Pointers, References, and Arrays</h2>
<p>An array is a collection of data available to all types:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="dt">char</span> s[<span class="dv">3</span>];</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="dt">int</span> numbers[<span class="dv">2</span>];</span></code></pre></div>
<p>The pointer-object relation can be established by,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">char</span> v[] = {<span class="st">&quot;H&quot;</span>, <span class="st">&quot;E&quot;</span>, <span class="st">&quot;L&quot;</span>, <span class="st">&quot;L&quot;</span>, <span class="st">&quot;O&quot;</span>}</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="dt">char</span>* ptr_h = &amp;v[<span class="dv">0</span>] <span class="co">// ptr_h points to address that is the 0th index of v (i.e., address of &quot;H&quot;)</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="dt">char</span>* ptr_h2 = ptr_h1 <span class="co">// ptr_h2 points to the same address as ptr_h</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="dt">char</span> h = *ptr_h <span class="co">// h is the content of ptr_h (i.e., &quot;H&quot;)</span></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="dt">char</span>&amp; ref_h = v[<span class="dv">0</span>] <span class="co">// ref_h references to the address that is the 0th index of v (i.e., address of &quot;H&quot;)</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="dt">char</span>&amp; ref_e = v[<span class="dv">1</span>]</span>
<span id="cb7-9"><a href="#cb7-9"></a>ref_e = ref_h <span class="co">// v is now has &quot;HHLLO&quot; because reference assignments auomatically dereference</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>              <span class="co">// without needing *</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="dt">void</span> func(<span class="dt">char</span>&amp; s) {} <span class="co">// Pass by reference, the argument s will be the object instead of a copy.</span></span></code></pre></div>
<p>Therefore there is a deep copy of an array is exprsesed as,</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">int</span>[] deepcopy(<span class="dt">int</span>[] arr) {</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="dt">int</span>[<span class="kw">sizeof</span>(arr)] copy_arr;</span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="cf">for</span> (<span class="kw">auto</span> i=<span class="dv">0</span>; i!=<span class="kw">sizeof</span>(arr); ++i) {</span>
<span id="cb8-5"><a href="#cb8-5"></a>        copy_arr[i] = arr[i];</span>
<span id="cb8-6"><a href="#cb8-6"></a>    }</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="cf">return</span> copy_arr;</span>
<span id="cb8-9"><a href="#cb8-9"></a>}</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="dt">int</span>[] shallowcopy(<span class="dt">int</span>[] arr) {</span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="dt">int</span>[<span class="kw">sizeof</span>(arr)] copy_arr;</span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="cf">for</span> (<span class="kw">auto</span> i=<span class="dv">0</span>; i!=<span class="kw">sizeof</span>(arr); ++i) {</span>
<span id="cb8-15"><a href="#cb8-15"></a>        copy_arr[i] = &amp;arr[i];</span>
<span id="cb8-16"><a href="#cb8-16"></a>    }</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="cf">return</span> arr</span>
<span id="cb8-18"><a href="#cb8-18"></a>}</span></code></pre></div>
<p><strong>Features</strong></p>
<ul>
<li><p>Declaration Operators</p>
<p>A declaration operator is a suffix unary operator taht determines whether the variable is an object, pointer, or reference:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a>Type arr[n] <span class="co">// arr is an array of n Type objects</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>Type* ptr  <span class="co">// ptr is a pointer to a Type object</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>Type&amp; ref <span class="co">// ref is a reference to a Type object</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>TypeA func(TypeB) <span class="co">// func is a function taking in TypeB object and returning TypeA object</span></span></code></pre></div></li>
<li><p>Null Pointer</p>
<p>All pointers need to point to something so all dereference is valid. A pointer will point to a null pointer whenever initialized as so,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>Type* ptr = <span class="kw">nullptr</span>;</span></code></pre></div></li>
</ul>
<h2 id="control-statements">Control Statements</h2>
<p>Standard if, for, and while are provided.</p>
<p><strong>Features</strong></p>
<ul>
<li><p>Switch cases, each <code>case</code> is ran until <code>break</code> otherwise <code>default</code> if exists or <code>pass</code>.</p></li>
<li><p>Define variables inside statements:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">bool</span> var = <span class="kw">true</span>;</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="cf">if</span> (<span class="kw">auto</span> cond=var; var) {</span>
<span id="cb11-3"><a href="#cb11-3"></a>    ...</span>
<span id="cb11-4"><a href="#cb11-4"></a>}</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">// Equivalently</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="cf">if</span> (<span class="kw">auto</span> cond=var) {</span>
<span id="cb11-8"><a href="#cb11-8"></a>    ...</span>
<span id="cb11-9"><a href="#cb11-9"></a>}</span></code></pre></div></li>
</ul>
